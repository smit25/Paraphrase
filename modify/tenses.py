# -*- coding: utf-8 -*-
"""tenses.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GHbT-pmaKIv1vp7LO2ebY3R6D7TBuTdY
"""

""" !pip install pattern3 """

import nltk
nltk.download('punkt')
nltk.download('averaged_perceptron_tagger')
import string
import pattern3
from pattern3.en import conjugate, PAST, PRESENT, SINGULAR, PLURAL
from spacy.symbols import NOUN
import spacy
from spacy.matcher import Matcher
#import en_core_web_sm
import spacy.cli
spacy.cli.download("en_core_web_sm")
# nlp = spacy.load('en_core_web_lg')
nlp = spacy.load('en_core_web_sm')

class Tense():
  def __init__(self, input_sent, para):
    super(Tense, self).__init__()

    self.input_sent = input_sent
    self.para = para
    self.SUBJ_DEPS = {'agent', 'csubj', 'csubjpass', 'expl', 'nsubj', 'nsubjpass'}

  def identify_tense(self, text):
    doc = nlp(text) # break the text into sentences
    sents = list(doc.sents)

    voice_dict = {}
    print_table = []
    tense = ''

    for sen in sents:
      doc = nlp(str(sen))

    # PRESENT TENSE EVALUATION
      matcher = Matcher(nlp.vocab) # Present perfect Continuous
      passive_rule = [{'DEP':'nsubj'}, {'LOWER' : 'has'}, {'LOWER': 'been'}, {'TAG':'VBG'}]
      matcher.add('Tense',None,passive_rule)
      matches = matcher(doc)
      if len(matches) != 0:
        for match_id, start, end in matches:
          span = doc[start:end]
          tense = 'Present Perfect Continuous'
      else:
        matcher = Matcher(nlp.vocab) # Present Perfect Continuous
        passive_rule = [{'DEP':'nsubj'}, {'LOWER' : 'have'}, {'LOWER': 'been'}, {'TAG':'VBG'}]
        matcher.add('Tense',None,passive_rule)
        matches = matcher(doc)
        if len(matches) != 0:
          for match_id, start, end in matches:
            span = doc[start:end]
          tense = 'Present Perfect Continuous'

        else:
          matcher = Matcher(nlp.vocab) # Present Perfect
          passive_rule = [{'DEP':'nsubj'}, {'LOWER' : 'has'}, {'TAG':'VBN'}]
          matcher.add('Tense',None,passive_rule)
          matches = matcher(doc)
          if len(matches) != 0:
            for match_id, start, end in matches:
              span = doc[start:end]
            tense = 'Present Perfect'
          else:
            matcher = Matcher(nlp.vocab) # Present Perfect
            passive_rule = [{'DEP':'nsubj'}, {'LOWER' : 'have'}, {'TAG':'VBN'}]
            matcher.add('Tense',None,passive_rule)
            matches = matcher(doc)
            if len(matches) != 0:
              for match_id, start, end in matches:
                span = doc[start:end]
              tense = 'Present Perfect'
            else:
              matcher = Matcher(nlp.vocab) # Simple Present
              passive_rule = [{'DEP':'nsubj'}, {'LOWER' : 'is'}, {'TAG':'VBG'}]
              matcher.add('Tense',None,passive_rule)
              matches = matcher(doc)
              if len(matches) != 0:
                for match_id, start, end in matches:
                  span = doc[start:end]
                  tense = 'Simple Present'
              else:
                matcher = Matcher(nlp.vocab) # Simple Present
                passive_rule = [{'DEP':'nsubj'}, {'LOWER' : 'am'}, {'TAG':'VBG'}]
                matcher.add('Tense',None,passive_rule)
                matches = matcher(doc)
                if len(matches) != 0:
                  for match_id, start, end in matches:
                    span = doc[start:end]
                  tense = 'Simple Present'
                else:
                  matcher = Matcher(nlp.vocab) # Simple Present
                  passive_rule = [{'DEP':'nsubj'}, {'LOWER' : 'are'}, {'TAG':'VBG'}]
                  matcher.add('Tense',None,passive_rule)
                  matches = matcher(doc)
                  if len(matches) != 0:
                    for match_id, start, end in matches:
                      span = doc[start:end]
                    tense = 'Simple Present'
                  else:
                    matcher = Matcher(nlp.vocab) # Simple Present
                    passive_rule = [{'DEP':'nsubj'},{'TAG':'VBZ'}]
                    matcher.add('Tense',None,passive_rule)
                    matches = matcher(doc)
                    if len(matches) != 0:
                      for match_id, start, end in matches:
                        span = doc[start:end]
                      tense = 'Simple Present'
                    else:
                      matcher = Matcher(nlp.vocab) # Simple Present
                      passive_rule = [{'DEP':'nsubj'},{'TAG':'VBP'}]
                      matcher.add('Tense',None,passive_rule)
                      matches = matcher(doc)
                      if len(matches) != 0:
                        for match_id, start, end in matches:
                          span = doc[start:end]
                        tense = 'Simple Present'

      # PAST TENSE EVALUATION
      matcher = Matcher(nlp.vocab) # Past Continuous
      passive_rule = [{'DEP':'nsubj'}, {'LOWER' : 'was'}, {'TAG':'VBG'}]
      matcher.add('Tense',None,passive_rule)
      matches = matcher(doc)
      if len(matches) != 0:
        for match_id, start, end in matches:
          span = doc[start:end]
        tense = 'Past Continuous'

      matcher = Matcher(nlp.vocab) # Past Continuous
      passive_rule = [{'DEP':'nsubj'}, {'LOWER' : 'were'}, {'TAG':'VBG'}]
      matcher.add('Tense',None,passive_rule)
      matches = matcher(doc)
      if len(matches) != 0:
        for match_id, start, end in matches:
          span = doc[start:end]
        tense = 'Past Continuous'

      matcher = Matcher(nlp.vocab) # Past Perfect Continuous
      passive_rule = [{'DEP':'nsubj'}, {'LOWER' : 'had'}, {'LOWER' : 'been'}, {'TAG':'VBG'}]
      matcher.add('Tense',None,passive_rule)
      matches = matcher(doc)
      if len(matches) != 0:
        for match_id, start, end in matches:
          span = doc[start:end]
        tense = 'Past Perfect Continuous'

      else:
        matcher = Matcher(nlp.vocab) # Past Perfect Continuous
        passive_rule = [{'DEP':'nsubj'}, {'LOWER' : 'had'}, {'TAG':'VBN'}]
        matcher.add('Tense',None,passive_rule)
        matches = matcher(doc)
        matches_past_perfect = matches
        if len(matches) != 0:
          for match_id, start, end in matches:
            span = doc[start:end]
          tense = 'Past Perfect'
        else:
          matcher = Matcher(nlp.vocab) # Past Continuous
          passive_rule = [{'DEP':'nsubj'}, {'LOWER' : 'was'}, {'TAG':'VBG'}]
          matcher.add('Tense',None,passive_rule)
          matches = matcher(doc)
          if len(matches) != 0:
            for match_id, start, end in matches:
              span = doc[start:end]
            tense = 'Past Continuous'

          else:
            matcher = Matcher(nlp.vocab) # Past Continuous
            passive_rule = [{'DEP':'nsubj'}, {'LOWER' : 'were'}, {'TAG':'VBG'}]
            matcher.add('Tense',None,passive_rule)
            matches = matcher(doc)
            if len(matches) != 0:
              for match_id, start, end in matches:
                span = doc[start:end]
              tense = 'Past Continuous'

            else:
              matcher = Matcher(nlp.vocab) # Simple Past
              passive_rule = [{'DEP':'nsubj'}, {'TAG':'VBD'}]
              matcher.add('Tense',None,passive_rule)
              matches = matcher(doc)
              if len(matches) != 0:
                for match_id, start, end in matches:
                  span = doc[start:end]
                tense = 'Simple Past'

      matcher = Matcher(nlp.vocab)
      passive_rule = [{'DEP':'nsubj'}, {'LOWER' : 'will'}, {'LOWER' : 'be'}, {'TAG':'VBG'}]
      matcher.add('Tense',None,passive_rule)
      matches = matcher(doc)
      if len(matches) != 0:
        for match_id, start, end in matches:
          span = doc[start:end]
        tense = 'Future Continuous'
      else:
        matcher = Matcher(nlp.vocab)
        passive_rule = [{'DEP':'nsubj'}, {'LOWER' : 'shall'}, {'LOWER' : 'be'}, {'TAG':'VBG'}]
        matcher.add('Tense',None,passive_rule)
        matches = matcher(doc)
        if len(matches) != 0:
          for match_id, start, end in matches:
            span = doc[start:end]
          tense = 'Future Continuous'

        else:
          matcher = Matcher(nlp.vocab)
          passive_rule = [{'DEP':'nsubj'}, {'LOWER' : 'will'}, {'LOWER' : 'have'}, {'TAG':'VBN'}]
          matcher.add('Tense',None,passive_rule)
          matches = matcher(doc)
          if len(matches) != 0:
            for match_id, start, end in matches:
              span = doc[start:end]
            tense = 'Future perfect'

          else:
            matcher = Matcher(nlp.vocab)
            passive_rule = [{'DEP':'nsubj'}, {'LOWER' : 'will'}, {'TAG':'VB'}]
            matcher.add('Tense',None,passive_rule)
            matches = matcher(doc)
            if len(matches) != 0:
              for match_id, start, end in matches:
                span = doc[start:end]
              tense = 'Simple Future'
    
            else:
              matcher = Matcher(nlp.vocab)
              passive_rule = [{'DEP':'nsubj'}, {'LOWER' : 'shall'}, {'TAG':'VB'}]
              matcher.add('Tense',None,passive_rule)
              matches = matcher(doc)
              if len(matches) != 0:
                for match_id, start, end in matches:
                  span = doc[start:end]
                tense = 'Simple Future'

    # FUTURE TENSE EVALUATION
      matcher = Matcher(nlp.vocab) # Future Perfect Continuous
      passive_rule = [{'DEP':'nsubj'}, {'LOWER' : 'will'}, {'LOWER' : 'have'}, {'LOWER' : 'been'}, {'TAG':'VBG'}]
      matcher.add('Tense',None,passive_rule)
      matches = matcher(doc)
      if len(matches) != 0:
        for match_id, start, end in matches:
          span = doc[start:end]
        tense = 'Future Perfect Continuous'

      row = [sen, tense, span]
      print_table.append(row)

    return print_table


    def _get_conjuncts(self, tok):
      """
      Return conjunct dependents of the leftmost conjunct in a coordinated phrase
      """
      return [right for right in tok.rights
            if right.dep_ == 'conj']

# Returns True if token is a plural noun else False
    def is_plural_noun(self, token):
      """
        token (``spacy.Token``)
        parent document must have POS information
      """
      if token.doc.is_tagged is False:
        print('ValueError')
      return True if token.pos == NOUN and token.lemma != token.lower else False

    def get_subjects_of_verb(verb):
      if verb.dep_ == "aux" and list(verb.ancestors):
        return get_subjects_of_verb(list(verb.ancestors)[0])
      """Return all subjects of a verb according to the dependency parse."""
      subjs = [tok for tok in verb.lefts
             if tok.dep_ in SUBJ_DEPS]
      # get additional conjunct subjects
      subjs.extend(tok for subj in subjs for tok in _get_conjuncts(subj))
      if not len(subjs):
        ancestors = list(verb.ancestors)
        if len(ancestors) > 0:
          return get_subjects_of_verb(ancestors[0])
      return subjs


    def is_plural_verb(self, token):
      if token.doc.is_tagged is False:
        raise ValueError('token is not POS-tagged')
      subjects = get_subjects_of_verb(token)
      if not len(subjects):
        return False
      plural_score = sum([is_plural_noun(x) for x in subjects])/len(subjects)

      return plural_score > .5

    # Returns newWord, capitalizing it if word is capitalized
    def preserve_caps(self, word, newWord):
      if word[0] >= 'A' and word[0] <= 'Z':
        newWord = newWord.capitalize()
      return newWord

# Change the tense of text.
    def change_tense(text, to_tense, nlp=nlp):
      """
      Args:
        text (str): text to change.
        to_tense (str): 'present','past', or 'future'
        npl (SpaCy model, optional):
      """
      tense_lookup = {'future': 'inf', 'present': PRESENT, 'past': PAST}
      tense = tense_lookup[to_tense]

      doc = nlp(text)

      out = list()
      out.append(doc[0].text)
      words = []
      for word in doc:
        words.append(word)
        if len(words) == 1:
            continue
        if (words[-2].text == 'will' and words[-2].tag_ == 'MD' and words[-1].tag_ == 'VB') or \
                        words[-1].tag_ in ('VBD', 'VBP', 'VBZ', 'VBN') or \
                (not words[-2].text in ('to', 'not') and words[-1].tag_ == 'VB'):

            if words[-2].text in ('were', 'am', 'is', 'are', 'was') or\
                    (words[-2].text == 'be' and len(words) > 2 and words[-3].text == 'will'):
                this_tense = tense_lookup['past']
            else:
                this_tense = tense

            subjects = [x.text for x in get_subjects_of_verb(words[-1])]
            if ('I' in subjects) or ('we' in subjects) or ('We' in subjects):
                person = 1
            elif ('you' in subjects) or ('You' in subjects):
                person = 2
            else:
                person = 3
            if is_plural_verb(words[-1]):
                number = PLURAL
            else:
                number = SINGULAR
            if (words[-2].text == 'will' and words[-2].tag_ == 'MD') or words[-2].text == 'had':
                out.pop(-1)
            if to_tense == 'future':
                if not (out[-1] == 'will' or out[-1] == 'be'):
                    out.append('will')
                # handle will as a noun in future tense
                if words[-2].text == 'will' and words[-2].tag_ == 'NN':
                    out.append('will')
            #if word_pair[0].dep_ == 'auxpass':
            oldWord = words[-1].text
            out.append(preserve_caps(oldWord, conjugate(oldWord, tense=this_tense, person=person, number=number)))
        else:
            out.append(words[-1].text)

        # negation
        if words[-2].text + words[-1].text in ('didnot', 'donot', 'willnot', "didn't", "don't", "won't"):
            if tense == PAST:
                out[-2] = 'did'
            elif tense == PRESENT:
                out[-2] = 'do'
            else:
                out.pop(-2)

        # future perfect, and progressives, but ignore for "I will have cookies"
        if words[-1].text in ('have', 'has') and len(list(words[-1].ancestors)) and words[-1].dep_ == 'aux':
            out.pop(-1)

      text_out = ' '.join(out)

    # Remove spaces before/after punctuation:
      for char in string.punctuation:
        if char in """(<['""":
            text_out = text_out.replace(char+' ', char)
        else:
            text_out = text_out.replace(' '+char, char)

      for char in ["-", "“", "‘"]:
        text_out = text_out.replace(char+' ', char)
      for char in ["…", "”", "'s", "n't"]:
        text_out = text_out.replace(' '+char, char)

      return text_out

  def main(self):
    output_sent = self.para
    tense1 = self.identify_tense(self.input_sent)
    tense2 = self.identify_tense(self.para)
    tense1, tense2 = tense1[0][1], tense2[0][1]
    if tense1 != tense2:
      to_tense = ''
      tense_list = tense1.split(' ')
      for word in tense_list:
        if word == 'Present':
          to_tense = 'present'
          break
        elif word == 'Past':
          to_tense = 'past'
          break
        elif word == 'Future':
          to_tense = 'future'
          break
      
      output_sent = self.change_tense(self.para, to_tense)
    return output_sent
